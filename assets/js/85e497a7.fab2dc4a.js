"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[9933],{8217:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>c,frontMatter:()=>a,metadata:()=>r,toc:()=>d});var i=t(4848),o=t(8453);const a={sidebar_position:2},s="Relationship Building",r={id:"tutorials-intermediate/relationship-building-techniques",title:"Relationship Building",description:"Technical documentation that may be misconstrued as life advice.",source:"@site/docs/tutorials-intermediate/relationship-building-techniques.md",sourceDirName:"tutorials-intermediate",slug:"/tutorials-intermediate/relationship-building-techniques",permalink:"/docs/docs/tutorials-intermediate/relationship-building-techniques",draft:!1,unlisted:!1,editUrl:"https://github.com/nodesteram-proj/docs/tree/main/packages/create-docusaurus/templates/shared/docs/tutorials-intermediate/relationship-building-techniques.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Modeling Source Nodes",permalink:"/docs/docs/tutorials-intermediate/source-nodes"},next:{title:"Data Massaging",permalink:"/docs/docs/tutorials-intermediate/data-massaging"}},l={},d=[{value:"Introduction",id:"introduction",level:2},{value:"Basic Relationship Building",id:"basic-relationship-building",level:2},{value:"Connecting to More Than One Node at a Time",id:"connecting-to-more-than-one-node-at-a-time",level:2},{value:"Multiple <code>relationship</code> Interpretations",id:"multiple-relationship-interpretations",level:3},{value:"<code>find_many</code> Key",id:"find_many-key",level:3},{value:"<code>iterate_on</code> Key",id:"iterate_on-key",level:3},{value:"Adding Properties to Relationships",id:"adding-properties-to-relationships",level:2},{value:"Adding Keys to Relationships",id:"adding-keys-to-relationships",level:2},{value:"Adding Properties to Related Nodes",id:"adding-properties-to-related-nodes",level:2},{value:"Flipping Relationship Directionality",id:"flipping-relationship-directionality",level:2},{value:"Preventing Related Nodes from Being Created",id:"preventing-related-nodes-from-being-created",level:2},{value:"Dynamic Node / Relationship Types",id:"dynamic-node--relationship-types",level:2},{value:"Caveats",id:"caveats",level:3}];function h(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"relationship-building",children:"Relationship Building"}),"\n",(0,i.jsx)(n.p,{children:"Technical documentation that may be misconstrued as life advice."}),"\n",(0,i.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,i.jsxs)(n.p,{children:["This tutorial covers advanced techniques for working with the ",(0,i.jsx)(n.code,{children:"relationship"})," interpretation in ",(0,i.jsx)(n.code,{children:"nodestream"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"nodestream"})," Interpreter works off the concept of the ",(0,i.jsx)(n.a,{href:"../source-nodes",children:"Source Node"}),".\nThis is the node that is conceptually at the center of the data being ingested.\nSince a relationship is defined in terms of the two nodes it connects, all we need to do after we have defined our source node is to define the other node that the source node is connected to."]}),"\n",(0,i.jsx)(n.h2,{id:"basic-relationship-building",children:"Basic Relationship Building"}),"\n",(0,i.jsxs)(n.p,{children:["Relationships are defined in the pipeline using the ",(0,i.jsx)(n.code,{children:"relationship"})," interpretation.\nThe ",(0,i.jsx)(n.code,{children:"relationship"})," interpretation is used to connect the source node to another node in the graph."]}),"\n",(0,i.jsx)(n.p,{children:"Imagine we are building a social network graph and are processing data about users and their friends.\nWe might have a source node that represents a user and a relationship that represents the user's friend that connects to another user node like so:"}),"\n",(0,i.jsx)(n.mermaid,{value:"graph TD\n    A[User] --\x3e|FRIENDS_WITH| B[User]"}),"\n",(0,i.jsx)(n.p,{children:"Presuming that the raw data looks like this:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n  "user": "John Doe",\n  "friend": "Jane Doe"\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"We would define our interpretations like this:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"# Future code examples will omit the source node for brevity\n- type: source_node\n  node_type: User\n  node_key:\n    name: !jmespath user\n- type: relationship\n  node_type: User\n  relationship_type: FRIENDS_WITH\n  node_key:\n    name: !jmespath friend\n"})}),"\n",(0,i.jsx)(n.p,{children:"This is a simple example, but it demonstrates the basic concept of connecting nodes in a graph."}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"relationship"})," interpretation is used to connect the source node to another node in the graph.\nBy default, the ",(0,i.jsx)(n.code,{children:"relationship"})," interpretation will create the related node if it does not already exist.\nIf the related node already exists, the ",(0,i.jsx)(n.code,{children:"relationship"})," interpretation will connect the source node to the existing node and update the node's properties."]})}),"\n",(0,i.jsx)(n.h2,{id:"connecting-to-more-than-one-node-at-a-time",children:"Connecting to More Than One Node at a Time"}),"\n",(0,i.jsx)(n.p,{children:"In many cases, the source node will be connected to more than one node at a time.\nThere are several techniques for handling this situation."}),"\n",(0,i.jsxs)(n.h3,{id:"multiple-relationship-interpretations",children:["Multiple ",(0,i.jsx)(n.code,{children:"relationship"})," Interpretations"]}),"\n",(0,i.jsxs)(n.p,{children:["The simplest way to handle this situation is to define multiple ",(0,i.jsx)(n.code,{children:"relationship"})," interpretations in the same pipeline.\nEach ",(0,i.jsx)(n.code,{children:"relationship"})," interpretation will connect the source node to a different node."]}),"\n",(0,i.jsx)(n.p,{children:"For example, consider the following raw data:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n  "user": "John Doe",\n  "follows": "Jane Doe",\n  "likes": "Bob Smith"\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"We might want to model this as a graph like this:"}),"\n",(0,i.jsx)(n.mermaid,{value:"graph TD\n    A[John Doe] --\x3e|FOLLOWS| B[Jane Doe]\n    A --\x3e|LIKES| C[Bob Smith]"}),"\n",(0,i.jsxs)(n.p,{children:["To accomplish this, we would need to define two ",(0,i.jsx)(n.code,{children:"relationship"})," interpretations in the same pipeline:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"- type: relationship\n  node_type: User\n  relationship_type: FOLLOWS\n  node_key:\n    name: !jmespath follows\n- type: relationship\n  node_type: User\n  relationship_type: LIKES\n  node_key:\n    name: !jmespath likes\n"})}),"\n",(0,i.jsxs)(n.p,{children:["This is simple, explicit, and easy to understand.\nHowever, it can be cumbersome if there are many relationships to define.\nStill, this is ",(0,i.jsx)(n.strong,{children:"the best"})," approach if the relationships do not share common configuration."]}),"\n",(0,i.jsxs)(n.h3,{id:"find_many-key",children:[(0,i.jsx)(n.code,{children:"find_many"})," Key"]}),"\n",(0,i.jsxs)(n.p,{children:["The next technique is to use the ",(0,i.jsx)(n.code,{children:"find_many"})," key. This flag tells ",(0,i.jsx)(n.code,{children:"nodestream"})," to interpret the provided key binding as a list of nodes, and to create a relationship to each of them. This is useful when the nodes to connecto to are all at the same level in the raw data and/or when they share the same configuration."]}),"\n",(0,i.jsx)(n.p,{children:"For example, consider the following raw data:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n  "user": "John Doe",\n  "follows": [\n    {\n      "name": "Jane Doe"\n    },\n    {\n      "name": "Bob Smith"\n    }\n  ]\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"We might want to model this as a graph like this:"}),"\n",(0,i.jsx)(n.mermaid,{value:"graph TD\n    A[John Doe] --\x3e|FOLLOWS| B[Jane Doe]\n    A --\x3e|FOLLOWS| C[Bob Smith]"}),"\n",(0,i.jsxs)(n.p,{children:["To accomplish this, we would use the ",(0,i.jsx)(n.code,{children:"find_many"})," key:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"- type: relationship\n  node_type: User\n  find_many: true\n  node_key:\n    name: !jmespath follows[*].name\n"})}),"\n",(0,i.jsx)(n.p,{children:"This is a more concise and expressive way to define the relationships.\nIt also works when the key of the related node is multiple parts. For example, if the raw data looked like this:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n  "first_name": "John",\n  "last_name": "Doe",\n  "follows": [\n    {\n      "first_name": "Jane",\n      "last_name": "Doe"\n    },\n    {\n      "first_name": "Bob",\n      "last_name": "Smith"\n    }\n  ]\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["We could still use the same ",(0,i.jsx)(n.code,{children:"find_many"})," key:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"- type: relationship\n  node_type: User\n  find_many: true\n  node_key:\n    first_name: !jmespath follows[*].first_name\n    last_name: !jmespath follows[*].last_name\n"})}),"\n",(0,i.jsxs)(n.p,{children:["This works by zipping the ",(0,i.jsx)(n.code,{children:"first_name"})," and ",(0,i.jsx)(n.code,{children:"last_name"})," arrays together and creating a relationship for each pair."]}),"\n",(0,i.jsxs)(n.h3,{id:"iterate_on-key",children:[(0,i.jsx)(n.code,{children:"iterate_on"})," Key"]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"iterate_on"})," key is similar to the ",(0,i.jsx)(n.code,{children:"find_many"})," key in the sense that it allows you to connect to more than one node at a time in the same relationship interpretation. However, it is more flexible in that allows you to iterate over an arbitrary structure and bind the keys (and properties) relative to the current iteration. What the heck does that mean? Let's see an example."]}),"\n",(0,i.jsx)(n.p,{children:"Consider the data we used in the previous example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n  "user": "John Doe",\n  "follows": [\n    {\n      "name": "Jane Doe"\n    },\n    {\n      "name": "Bob Smith"\n    }\n  ]\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["The equivlent interpretation using the ",(0,i.jsx)(n.code,{children:"iterate_on"})," key would look like this:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"- type: relationship\n  node_type: User\n  iterate_on: !jmespath follows[*]\n  node_key:\n    name: !jmespath name\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In this example, the benefit of using the ",(0,i.jsx)(n.code,{children:"iterate_on"})," key is not immediately obvious.\nHowever, it will be more clear when we add properties to the relationship, which we will cover in the next section."]}),"\n",(0,i.jsx)(n.h2,{id:"adding-properties-to-relationships",children:"Adding Properties to Relationships"}),"\n",(0,i.jsx)(n.p,{children:"By default, a relationship comes with relatively few properties on it.\nMany domain models require additional properties to be added to relationships.\nFor example, consider a social network where users can follow other users."}),"\n",(0,i.jsx)(n.p,{children:"Given raw data like this:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n  "user": "John Doe",\n  "follows": [\n    {\n      "name": "Jane Doe",\n      "since": "2021-01-01"\n    },\n    {\n      "name": "Bob Smith",\n      "since": "2021-01-15"\n    }\n  ]\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"We might want to model this as a graph like this:"}),"\n",(0,i.jsx)(n.mermaid,{value:"graph TD\n    A[User] --\x3e|FOLLOWS since 2017| B[User]\n    A --\x3e|FOLLOWS since 2021| C[User]"}),"\n",(0,i.jsxs)(n.p,{children:["To accomplish this, we would need to add a ",(0,i.jsx)(n.code,{children:"since"})," property to the relationship between the user and the user they follow.\nThat can be done with the following interpretation:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"- type: relationship\n  node_type: User\n  relationship_type: FOLLOWS\n  iterate_on: !jmespath follows[*]  # Iterate over each user the user follows\n  node_key:\n    name: !jmespath name\n  relationship_properties:\n    since: !jmespath since\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Here we use the ",(0,i.jsx)(n.code,{children:"relationship_properties"})," key to map the properties we want to add to the relationship to the corresponding values in the raw data.\nNote that in this example, we are using the ",(0,i.jsx)(n.code,{children:"iterate_on"})," key to iterate over each user the user follows but this also works with a flat data structure. For example, if the raw data looked like this:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n  "user": "John Doe",\n  "follows": "Jane Doe",\n  "since": "2021-01-01"\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"We could use the following interpretation:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"- type: relationship\n  node_type: User\n  relationship_type: FOLLOWS\n  node_key:\n    name: !jmespath follows\n  relationship_properties:\n    since: !jmespath since\n"})}),"\n",(0,i.jsx)(n.h2,{id:"adding-keys-to-relationships",children:"Adding Keys to Relationships"}),"\n",(0,i.jsx)(n.p,{children:"By default, a relationship is generally defined as unique by the combination of the specific nodes it connects and the type of the relationship.\nIn other words, only one relationship of a given type can exist between any two nodes."}),"\n",(0,i.jsx)(n.p,{children:"However, many data models require relationships to be unique based on some other property.\nFor example, take a permissions model where a user can have many roles within an organization."}),"\n",(0,i.jsx)(n.p,{children:"Given raw data like this:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n  "name": "John Doe",\n  "roles": [\n    {\n      "name": "owner",\n      "organization": {\n        "name": "Acme Corp"\n      }\n    },\n    {\n      "name": "admin",\n      "organization": {\n        "name": "Acme Corp"\n      }\n    }\n  ]\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"We might want to model this as a graph like this:"}),"\n",(0,i.jsx)(n.mermaid,{value:"graph TD\n    A[User] --\x3e|HAS_MEMBERSHIP role=owner| B[Organization]\n    A --\x3e|HAS_MEMBERSHIP role=admin| B"}),"\n",(0,i.jsx)(n.p,{children:"In such a case, we would want to ensure that the user node has two relationships to the organization, one for each role.\nBased on what we've learned so far, one might expect something like this to work:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"# does-not-work.yaml\n- type: relationship\n  node_type: Organization\n  relationship_type: HAS_MEMBERSHIP\n  iterate_on: !jmespath roles[*]  # Iterate over each role\n  node_key:\n    # Get the name of the organization; this will be used to uniquely identify the node.\n    name: !jmespath organization.name\n  relationship_properties:\n    role: !jmespath name\n"})}),"\n",(0,i.jsxs)(n.p,{children:["While this ",(0,i.jsx)(n.em,{children:"does"})," work, it will ",(0,i.jsx)(n.em,{children:"only"})," create ",(0,i.jsx)(n.strong,{children:"one"})," relationship between the user and the organization, and it will have the properties of the last role in the list. Not what we want."]}),"\n",(0,i.jsxs)(n.p,{children:["To get this to work, we can add a ",(0,i.jsx)(n.code,{children:"relationship_key"})," section instead of a ",(0,i.jsx)(n.code,{children:"relationship_properties"})," section to the relationship interpretation. This tells nodestream to deduplicate relationships by accounting for the defined key of the relationship in addition to the nodes its relating. This will create two relationships between the user and the organization, one for each role. ","\ud83c\udf89"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"# does-work.yaml\n- type: relationship\n  node_type: Organization\n  relationship_type: HAS_MEMBERSHIP\n  iterate_on: !jmespath roles[*] # Iterate over each role\n  node_key:\n    # Get the name of the organization; this will be used to uniquely identify the node.\n    name: !jmespath organization.name\n  relationship_key:\n    # Get the name of the role; this will be used to uniquely identify the relationship.\n    role: !jmespath name\n"})}),"\n",(0,i.jsx)(n.h2,{id:"adding-properties-to-related-nodes",children:"Adding Properties to Related Nodes"}),"\n",(0,i.jsx)(n.p,{children:"In some cases, you may want to add properties to the related nodes themselves.\nFor example, consider a social network where we are modeling users and liked  posts."}),"\n",(0,i.jsx)(n.p,{children:"Given raw data like this:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n  "user": "John Doe",\n  "liked_posts": [123, 456],\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"We might want to update our graph like this:"}),"\n",(0,i.jsx)(n.mermaid,{value:"graph LR\n    A[John Doe] --\x3e|LIKED| B[Post last_liked_by=John Doe]"}),"\n",(0,i.jsxs)(n.p,{children:["To accomplish this, we would need to add a ",(0,i.jsx)(n.code,{children:"last_liked_by"})," property to the Post node that John Doe liked.\nWhile you can flatten the data or flip the ingestion around so that the Post is the source node, these are not always feasible options and are indirect solutions to the problem.\nInstead, you can use the ",(0,i.jsx)(n.code,{children:"node_properties"})," key to add properties to the related nodes."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"- type: relationship\n  node_type: User\n  relationship_type: LIKED\n  find_many: true\n  node_key:\n    id: !jmespath liked_posts[*]\n  node_properties:\n    last_liked_by: !jmespath user\n"})}),"\n",(0,i.jsx)(n.h2,{id:"flipping-relationship-directionality",children:"Flipping Relationship Directionality"}),"\n",(0,i.jsxs)(n.p,{children:["In nodestream all relationships are directed, meaning that they have a source and a target node.\nBy default, relationships are directed from the source node to the target node.\nHowever, you can change flip the direction of the relationship by setting the ",(0,i.jsx)(n.code,{children:"outbound"})," key to ",(0,i.jsx)(n.code,{children:"false"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"For example, consider our previous example with a social network where we are modeling users and liked posts."}),"\n",(0,i.jsx)(n.p,{children:"Given raw data like this:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n  "user": "John Doe",\n  "liked_posts": [123, 456],\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"We might want to update our graph like this:"}),"\n",(0,i.jsx)(n.mermaid,{value:"graph LR\n    A[POST] --\x3e|WAS_LIKED_BY| B[John Doe]"}),"\n",(0,i.jsxs)(n.p,{children:["To accomplish this, we would need to set the ",(0,i.jsx)(n.code,{children:"outbound"})," key to ",(0,i.jsx)(n.code,{children:"false"})," in the relationship interpretation."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"- type: relationship\n  node_type: Post\n  relationship_type: WAS_LIKED_BY\n  find_many: true\n  node_key:\n    id: !jmespath liked_posts[*]\n  outbound: false\n"})}),"\n",(0,i.jsx)(n.h2,{id:"preventing-related-nodes-from-being-created",children:"Preventing Related Nodes from Being Created"}),"\n",(0,i.jsxs)(n.p,{children:["By default, nodestream will create nodes for related nodes if they do not already exist.\nHowever, you can prevent this behavior by setting the ",(0,i.jsx)(n.code,{children:"node_creation_rule"})," key to either ",(0,i.jsx)(n.code,{children:"MATCH_ONLY"})," or ",(0,i.jsx)(n.code,{children:"FUZZY"}),"."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"MATCH_ONLY"})," will only create a relationship if the related node already exists. If the related node does not exist, the relationship will not be created."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"FUZZY"})," will treat the key properties as regular expressions and will only create a relationship to the nodes that match the regular expression. If no nodes match the regular expression, the relationship will not be created."]}),"\n"]}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsx)(n.p,{children:"This is only supported for string properties and has a performance impact and should be used with caution."})}),"\n",(0,i.jsx)(n.h2,{id:"dynamic-node--relationship-types",children:"Dynamic Node / Relationship Types"}),"\n",(0,i.jsx)(n.p,{children:"In some cases, you may want to dynamically set the type of the relationship based on the data. For example, recall our permissions model where a user can have many roles within an organization."}),"\n",(0,i.jsx)(n.p,{children:"Given raw data like this:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n  "name": "John Doe",\n  "roles": [\n    {\n      "name": "OWNER",\n      "organization": {\n        "name": "Acme Corp"\n      }\n    },\n    {\n      "name": "ADMIN",\n      "organization": {\n        "name": "Acme Corp"\n      }\n    }\n  ]\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"We might want to model this as a graph like this:"}),"\n",(0,i.jsx)(n.mermaid,{value:"graph TD\n    A[User] --\x3e|ADMIN| B[Organization]\n    A --\x3e|OWNER| B"}),"\n",(0,i.jsxs)(n.p,{children:["To accomplish this, we can use the ",(0,i.jsx)(n.code,{children:"relationship_type"})," key to dynamically set the type of the relationship based on the data as we would with any other field."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"- type: relationship\n  node_type: Organization\n  iterate_on: !jmespath roles[*]\n  relationship_type: !jmespath name\n  node_key:\n    name: !jmespath organization.name\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Similarly, you can use the ",(0,i.jsx)(n.code,{children:"node_type"})," key to dynamically set the type of the related node based on the data as we would with any other field."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"- type: relationship\n  node_type: !jmespath organization.name\n  iterate_on: !jmespath roles[*]\n  relationship_type: !jmespath name\n  node_key:\n    name: !jmespath organization.name\n"})}),"\n",(0,i.jsx)(n.h3,{id:"caveats",children:"Caveats"}),"\n",(0,i.jsx)(n.p,{children:"These features come with some VERY IMPORTANT caveats."}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"The relationship/node type must be a string."}),"\n",(0,i.jsx)(n.li,{children:"The relationship/node type must be a valid identifier for your underlying database."}),"\n",(0,i.jsxs)(n.li,{children:["The data you are using to set the relationship type ",(0,i.jsx)(n.strong,{children:"MUST BE"})," sanitized and validated to prevent injection attacks. This is especially important if the data is coming from an untrusted source."]}),"\n",(0,i.jsx)(n.li,{children:"Because the relationship/node type is dynamic, it is not possible to have the interpretaions that use this feature to be pre-validated by the schema. Migrations, for example, cannot prepare the database appropriately for this data type. So manual intervention may be required to ensure that the database is properly configured to handle the data."}),"\n",(0,i.jsx)(n.li,{children:"For the same reason, it is not possible for the schema system to know what the relationship/node type will be, so many of the features that rely on the schema system will not work with this feature."}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"In general, it is best to avoid using this feature if at all possible"}),". If you find yourself needing to use this feature, it is a good idea to take a step back and consider if there is a better way to model your data."]})]})}function c(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>r});var i=t(6540);const o={},a=i.createContext(o);function s(e){const n=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);