"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[4278],{5891:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>d});var a=t(4848),i=t(8453);const r={sidebar_position:3},o="Data Massaging",s={id:"tutorials-intermediate/data-massaging",title:"Data Massaging",description:"How to massage input data into records that you want to interpret.",source:"@site/docs/tutorials-intermediate/data-massaging.md",sourceDirName:"tutorials-intermediate",slug:"/tutorials-intermediate/data-massaging",permalink:"/docs/docs/tutorials-intermediate/data-massaging",draft:!1,unlisted:!1,editUrl:"https://github.com/nodesteram-proj/docs/tree/main/packages/create-docusaurus/templates/shared/docs/tutorials-intermediate/data-massaging.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Relationship Building",permalink:"/docs/docs/tutorials-intermediate/relationship-building-techniques"},next:{title:"Data Filtering",permalink:"/docs/docs/tutorials-intermediate/filtering-data"}},l={},d=[{value:"Introduction",id:"introduction",level:2},{value:"Normalization Flags",id:"normalization-flags",level:2},{value:"Normalizing in the <code>source_node</code> Interpretation",id:"normalizing-in-the-source_node-interpretation",level:3},{value:"Normalizing in the <code>relationship</code> Interpretation",id:"normalizing-in-the-relationship-interpretation",level:3},{value:"Normalzing Values inline",id:"normalzing-values-inline",level:3},{value:"Interpreter Tricks",id:"interpreter-tricks",level:2},{value:"Handling Nested Data Structures",id:"handling-nested-data-structures",level:3},{value:"Ingesting Deeper Relationship Hierarchies",id:"ingesting-deeper-relationship-hierarchies",level:3},{value:"Variables",id:"variables",level:3},{value:"Projecting Data with the <code>ValueProjection</code> Transformer",id:"projecting-data-with-the-valueprojection-transformer",level:2},{value:"Working with Strings",id:"working-with-strings",level:2},{value:"Concatenation and Formatting",id:"concatenation-and-formatting",level:3},{value:"Splitting Strings",id:"splitting-strings",level:3},{value:"Extracting Values With Regular Expressions",id:"extracting-values-with-regular-expressions",level:3}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",mermaid:"mermaid",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.h1,{id:"data-massaging",children:"Data Massaging"}),"\n",(0,a.jsx)(n.p,{children:"How to massage input data into records that you want to interpret."}),"\n",(0,a.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,a.jsx)(n.p,{children:"In previous sections, you learned how to interpret simple data into nodes and relationships.\nUnfortunately, input data is rarely in the exact format that you need.\nIn this section, you will learn how to massage input data and process it such that it can easily be interpreted into nodes and relationships."}),"\n",(0,a.jsx)(n.h2,{id:"normalization-flags",children:"Normalization Flags"}),"\n",(0,a.jsxs)(n.p,{children:["Normalization flags are a way to tell a given intepretation to normalize a scalar value before interpreting it. For example, you might want to normalize a string to lowercase before using it as a node key. Flags are specified in the various intepretation clauses such as ",(0,a.jsx)(n.code,{children:"source_node"})," and ",(0,a.jsx)(n.code,{children:"relationship"}),"."]}),"\n",(0,a.jsxs)(n.h3,{id:"normalizing-in-the-source_node-interpretation",children:["Normalizing in the ",(0,a.jsx)(n.code,{children:"source_node"})," Interpretation"]}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"source_node"})," interpretation has a block to specify normalization flags:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:"- type: source_node\n  node_type: Person\n  key:\n    first_name: !jmespath name\n    last_name: !jmespath surname\n  normalization:\n    do_trim_whitespace: true\n"})}),"\n",(0,a.jsxs)(n.p,{children:["This example will trim whitespace from a string before storing the value were defined.\nBy default, the ",(0,a.jsx)(n.code,{children:"do_lowercase_strings"})," flag is set to ",(0,a.jsx)(n.code,{children:"true"})," unless explicitly disabled.\nIf you want to disable this, you can set it to ",(0,a.jsx)(n.code,{children:"false"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:"- type: source_node\n  node_type: Person\n  key:\n    first_name: !jmespath name\n    last_name: !jmespath surname\n  normalization:\n    do_lowercase_strings: false\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Of course, you may also combine a series of flags together.\nThe order of normalization flags is not guaranteed, so be careful when combining flags that depend on the order of operations.\nIf that is the case, you may want to use a transformer to normalize the data before interpreting it.\nSee ",(0,a.jsx)(n.a,{href:"../../tutorials-advanced/new-steps#creating-a-transformer",children:"Creating Custom Transformers"})," for more information."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:"- type: source_node\n  node_type: Person\n  key:\n    first_name: !jmespath name\n    last_name: !jmespath surname\n  normalization:\n    do_lowercase_strings: false\n    do_trim_whitespace: true\n"})}),"\n",(0,a.jsx)(n.p,{children:"If you want to apply different normalization rules to keys than you do to properties, it is recommended you use a properties interpretation\nafter the source node interpretation to apply the different normalization rules. For example:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:"- type: source_node\n  node_type: Person\n  key:\n    first_name: !jmespath name\n    last_name: !jmespath surname\n  normalization:\n    do_trim_whitespace: true\n- type: properties\n  properties:\n    status: !jmespath status\n  normalization:\n    do_lowercase_strings: true\n"})}),"\n",(0,a.jsxs)(n.p,{children:["This example will trim whitespace from the ",(0,a.jsx)(n.code,{children:"first_name"})," and ",(0,a.jsx)(n.code,{children:"last_name"})," keys, and lowercase the ",(0,a.jsx)(n.code,{children:"status"})," property."]}),"\n",(0,a.jsxs)(n.h3,{id:"normalizing-in-the-relationship-interpretation",children:["Normalizing in the ",(0,a.jsx)(n.code,{children:"relationship"})," Interpretation"]}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"relationship"})," interpretation allows for two different sets of normalization flags: one for the key and one for the properties."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:"- type: relationship\n  relationship_type: IS_MEMBER_OF\n  node_type: Organization\n  node_key:\n    name: !jmespath organization.name\n  node_properties:\n    tax_id_number: !jmespath organization.tax_id_number\n  relationship_key:\n    role: !jmespath role\n  relationship_properties:\n    start_date: !jmespath start_date\n  key_normalization:\n    do_lowercase_strings: true\n  property_normalization:\n    do_trim_whitespace: true\n"})}),"\n",(0,a.jsxs)(n.p,{children:["The key normalization flags will be applied to both the ",(0,a.jsx)(n.code,{children:"node_key"})," and ",(0,a.jsx)(n.code,{children:"relationship_key"})," clauses, while the property normalization flags will be applied to both the ",(0,a.jsx)(n.code,{children:"node_properties"})," and ",(0,a.jsx)(n.code,{children:"relationship_properties"})," clauses.\nCurrently, there is no way to apply different normalization rules to the ",(0,a.jsx)(n.code,{children:"node_key"})," and ",(0,a.jsx)(n.code,{children:"relationship_key"})," clauses, or to the ",(0,a.jsx)(n.code,{children:"node_properties"})," and ",(0,a.jsx)(n.code,{children:"relationship_properties"})," clauses globally. However, you can use ",(0,a.jsx)(n.a,{href:"#normalzing-values-inline",children:(0,a.jsx)(n.code,{children:"!normalize"})})," to apply different normalization rules inline. For example:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:"- type: relationship\n  relationship_type: IS_MEMBER_OF\n  node_type: Organization\n  node_key:\n    name: !normalize\n      using: trim_whitespace\n      data: !jmespath organization.name\n  node_properties:\n    tax_id_number: !jmespath organization.tax_id_number\n  relationship_key:\n    role: !jmespath role\n  relationship_properties:\n    start_date: !jmespath start_date\n  key_normalization:\n    do_lowercase_strings: true\n  property_normalization:\n    do_trim_whitespace: true\n"})}),"\n",(0,a.jsx)(n.h3,{id:"normalzing-values-inline",children:"Normalzing Values inline"}),"\n",(0,a.jsxs)(n.p,{children:["Nodestream has the yaml tag ",(0,a.jsx)(n.code,{children:"!normalize"})," that can be used to normalize a value inline:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:'- type: source_node\n  node_type: !normalize "Person"\n  key:\n    first_name: !normalize\n      using: trim_whitespace\n      data: !jmespath name\n    last_name: !jmespath surname\n'})}),"\n",(0,a.jsxs)(n.p,{children:["This allows you to normalize values inline without having to use the ",(0,a.jsx)(n.code,{children:"key_normalization"})," and ",(0,a.jsx)(n.code,{children:"property_normalization"})," flags, which apply to all values in a given clause."]}),"\n",(0,a.jsx)(n.h2,{id:"interpreter-tricks",children:"Interpreter Tricks"}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"Interpreter"})," class has a few tricks up its sleeve to handle some common data massaging tasks without additional transformers and other processing steps."]}),"\n",(0,a.jsx)(n.h3,{id:"handling-nested-data-structures",children:"Handling Nested Data Structures"}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"iterate_on"})," and ",(0,a.jsx)(n.code,{children:"before_iteration"})," clauses are used to handle nested data structures that need to be iterated over while interpreting.\nEssentially, the ",(0,a.jsx)(n.code,{children:"iterate_on"})," clause is used to specify a JMESPath expression that will return a list of records to be iterated over from the input data.\nThe ",(0,a.jsx)(n.code,{children:"before_iteration"})," clause is used to specify a set of interpretations that should be applied to each record before the ",(0,a.jsx)(n.code,{children:"iterate_on"})," is applied."]}),"\n",(0,a.jsx)(n.p,{children:"For example, consider the following input data:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-json",children:'{\n  "organization": {\n    "name": "Acme Inc."\n  },\n  "people": [\n    {\n      "name": "John",\n      "surname": "Doe",\n      "age": 30,\n      "contact": {\n        "email": "jdoe@example.com",\n        "phone": "555-555-5555"\n    },\n    {\n      "name": "Jane",\n      "surname": "Doe",\n      "age": 28,\n      "contact": {\n        "email": "jane_doe@example.com",\n        "phone": "555-555-5555"\n    }\n  ]\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["You can use the ",(0,a.jsx)(n.code,{children:"iterate_on"})," and ",(0,a.jsx)(n.code,{children:"before_iteration"})," clauses to interpret the ",(0,a.jsx)(n.code,{children:"people"})," array as a set of ",(0,a.jsx)(n.code,{children:"Person"})," nodes and ",(0,a.jsx)(n.code,{children:"IS_MEMBER_OF"})," relationships to the ",(0,a.jsx)(n.code,{children:"Organization"})," node while also interpreting the ",(0,a.jsx)(n.code,{children:"contact"})," object as a set of ",(0,a.jsx)(n.code,{children:"Contact"})," nodes and ",(0,a.jsx)(n.code,{children:"HAS_CONTACT"})," relationships to the ",(0,a.jsx)(n.code,{children:"Person"})," node."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:"- implementation: nodestream.interpreting:Interpreter\n  arguments:\n    before_iteration:\n      - type: relationship\n        relationship_type: IS_MEMBER_OF\n        node_type: Organization\n        node_key:\n          name: !jmespath organization.name\n    iterate_on: !jmespath people\n    interpretations:\n      - type: source_node\n        node_type: Person\n        key:\n          first_name: !jmespath name\n          last_name: !jmespath surname\n      - type: relationship\n        relationship_type: HAS_CONTACT\n        node_type: Email\n        node_key:\n          email: !jmespath contact.email\n      - type: relationship\n        relationship_type: HAS_CONTACT\n        node_type: Phone\n        node_key:\n          phone: !jmespath contact.phone\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Note, the ",(0,a.jsx)(n.code,{children:"before_iteration"})," clause is defined relative to the whole input record. The ",(0,a.jsx)(n.code,{children:"iterate_on"})," clause is also defined relative to the whole input record but sets the scope for the ",(0,a.jsx)(n.code,{children:"interpretations"})," clause. This means that the ",(0,a.jsx)(n.code,{children:"before_iteration"})," clause is applied to the whole input record, while the ",(0,a.jsx)(n.code,{children:"interpretations"})," clause is applied to each record in the ",(0,a.jsx)(n.code,{children:"people"})," array. Conceptually, the interpreter executes this pseudocode:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"# original_input_record is the input data\n\nfor sub_item in original_input_record.break_down_from_jmespath(iterate_on_clause):\n    for interpretation in before_iteration:\n        interpretation.execute(original_input_record)\n    for interpretation in interpretations:\n        interpretation.execute(sub_item)\n"})}),"\n",(0,a.jsx)(n.h3,{id:"ingesting-deeper-relationship-hierarchies",children:"Ingesting Deeper Relationship Hierarchies"}),"\n",(0,a.jsxs)(n.p,{children:["Imagine you have a data structure that is deeper with three hops.\nFor example, you have a ",(0,a.jsx)(n.code,{children:"Person"})," node that has a ",(0,a.jsx)(n.code,{children:"HAS_CONTACT"})," relationship to a ",(0,a.jsx)(n.code,{children:"Contact"})," node, which has a ",(0,a.jsx)(n.code,{children:"HAS_ADDRESS"})," relationship to an ",(0,a.jsx)(n.code,{children:"Address"})," node. For example:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-json",children:'{\n  "name": "John",\n  "surname": "Doe",\n  "contact": {\n    "email": "jdoe@example.com"\n  }\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"variables",children:"Variables"}),"\n",(0,a.jsx)(n.p,{children:"Variables have to uses inside of nodestream:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Like a programming language, use them to refer to the same value in multiple places."}),"\n",(0,a.jsxs)(n.li,{children:["Use them to save a value in ",(0,a.jsx)(n.code,{children:"before_iteration"})," and use it in ",(0,a.jsx)(n.code,{children:"interpretations"}),"."]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"For example, consider the following input data:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-json",children:'{\n  "organization": {\n    "name": "Acme Inc."\n  },\n  "people": [\n    {\n      "name": "John",\n      "surname": "Doe",\n      "age": 30,\n    }\n  ]\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["You can use a variable to refer to the ",(0,a.jsx)(n.code,{children:"organization.name"})," value in multiple places. For example:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:"- implementation: nodestream.interpreting:Interpreter\n  arguments:\n    before_iteration:\n      - type: variables\n        variables:\n          organization_name: !jmespath organization.name\n    iterate_on: !jmespath people\n    interpretations:\n      - type: source_node\n        node_type: Person\n        key:\n          first_name: !jmespath name\n          last_name: !jmespath surname\n      - type: relationship\n        relationship_type: IS_MEMBER_OF\n        node_type: Organization\n        node_key:\n          name: !variable organization_name\n"})}),"\n",(0,a.jsxs)(n.h2,{id:"projecting-data-with-the-valueprojection-transformer",children:["Projecting Data with the ",(0,a.jsx)(n.code,{children:"ValueProjection"})," Transformer"]}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"ValueProjection"})," transformer is used to project a value from the input into one or more output values.\nThis is useful for unwinding a list of values into multple records, or for extracting a value from a nested data structure."]}),"\n",(0,a.jsx)(n.p,{children:"For example, consider the following input data:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-json",children:'{\n  "organization": {\n    "name": "Acme Inc."\n  },\n  "people": [\n    {\n      "name": "John",\n      "surname": "Doe",\n      "age": 30\n    },\n    {\n      "name": "Jane",\n      "surname": "Doe",\n      "age": 30\n    }\n  ]\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"But we'd rather have the data look like this:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-json",children:'{\n  "members": [\n    {\n      "name": "John",\n      "surname": "Doe",\n      "age": 30\n    },\n    {\n      "name": "Jane",\n      "surname": "Doe",\n      "age": 30\n    }\n  ],\n  "org_name": "Acme Inc."\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["You can use the ",(0,a.jsx)(n.code,{children:"ValueProjection"})," transformer to project the ",(0,a.jsx)(n.code,{children:"organization.name"})," value into the ",(0,a.jsx)(n.code,{children:"org_name"})," field and the ",(0,a.jsx)(n.code,{children:"people"})," array into the ",(0,a.jsx)(n.code,{children:"members"})," field. For example:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:'- implementation: nodestream.pipeline.transformers:ValueProjection\n  arguments:\n    projection: !jmespath "{org_name: organization.name, members: people[*]}"\n'})}),"\n",(0,a.jsx)(n.p,{children:"This is also commonly used for unwding arrays.\nFor example, consider the following input data:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-json",children:'{\n  "organization": {\n    "name": "Acme Inc."\n  },\n  "people": [\n    {\n      "name": "John",\n      "surname": "Doe",\n      "age": 30\n    },\n    {\n      "name": "Jane",\n      "surname": "Doe",\n      "age": 30\n    }\n  ]\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"But we'd rather have the data look like this:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-json",children:'{\n  "name": "John",\n  "surname": "Doe",\n  "age": 30,\n  "organization": {\n    "name": "Acme Inc."\n  }\n}\n{\n  "name": "Jane",\n  "surname": "Doe",\n  "age": 30,\n  "organization": {\n    "name": "Acme Inc."\n  }\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["You can use the ",(0,a.jsx)(n.code,{children:"ValueProjection"})," transformer to unwind the ",(0,a.jsx)(n.code,{children:"people"})," array into multiple records and inject the ",(0,a.jsx)(n.code,{children:"organization"})," object into each record. For example:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:'- implementation: nodestream.pipeline.transformers:ValueProjection\n  arguments:\n    projection: !jmespath "people[*]"\n    additional_values:\n      organization: !jmespath "organization"\n'})}),"\n",(0,a.jsx)(n.h2,{id:"working-with-strings",children:"Working with Strings"}),"\n",(0,a.jsx)(n.p,{children:"Everyone loves working with strings, right? Here are some common string operations you might need to perform."}),"\n",(0,a.jsx)(n.h3,{id:"concatenation-and-formatting",children:"Concatenation and Formatting"}),"\n",(0,a.jsxs)(n.p,{children:["Nodestream supports string concatentation and formatting by with ",(0,a.jsx)(n.code,{children:"!format"}),".\nFor example, if you wanted to create a hello world node based on a name field in the record, you could do the following:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:'- implementation: nodestream.interpreting:Interpreter\n  arguments:\n    interpretations:\n      - type: variables\n        variables:\n          hello_world: !format\n            fmt: "Hello, {name}!"\n            name: !jmespath name\n      - type: source_node\n        node_type: HelloWorld\n        key:\n          message: !variable hello_world\n'})}),"\n",(0,a.jsxs)(n.p,{children:["Note, while you can use ",(0,a.jsx)(n.code,{children:"!format"})," anywhere you might expect, its often a bit more readable to use it in the ",(0,a.jsx)(n.code,{children:"variables"})," section."]}),"\n",(0,a.jsx)(n.h3,{id:"splitting-strings",children:"Splitting Strings"}),"\n",(0,a.jsxs)(n.p,{children:["You can split a string into multiple values using the ",(0,a.jsx)(n.code,{children:"!split"})," function.\nFor example, if you wanted to split a comma-separated list of tags into an array like this:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-json",children:'{\n  "post_id": "123",\n  "tags": "tag1,tag2,tag3"\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["You can use the ",(0,a.jsx)(n.code,{children:"!split"})," function to split the ",(0,a.jsx)(n.code,{children:"tags"})," string into an array. For example:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:'- implementation: nodestream.interpreting:Interpreter\n  arguments:\n    interpretations:\n      - type: source_node\n        node_type: Post\n        key:\n          id: !jmespath post_id\n      - type: relationship\n        relationship_type: HAS_TAG\n        node_type: Tag\n        find_many: true\n        node_key:\n          name: !split\n            string: !jmespath tags\n            delimiter: ","\n'})}),"\n",(0,a.jsx)(n.p,{children:"Which produces a graph like this:"}),"\n",(0,a.jsx)(n.mermaid,{value:"graph TD\n  Post --\x3e|HAS_TAG| Tag1\n  Post --\x3e|HAS_TAG| Tag2\n  Post --\x3e|HAS_TAG| Tag3"}),"\n",(0,a.jsx)(n.h3,{id:"extracting-values-with-regular-expressions",children:"Extracting Values With Regular Expressions"}),"\n",(0,a.jsxs)(n.p,{children:["Despte best intentions, sometimes you'll need to regex out a value from a string. ",(0,a.jsx)(n.code,{children:"nodestream"})," provides a ",(0,a.jsx)(n.code,{children:"!regex"})," function to help with this."]}),"\n",(0,a.jsx)(n.p,{children:"For example, consider the following input data:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-json",children:'{\n  "post_id": "p-123"\n  "title": "Post 123: Hello, World!"\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["You can use the ",(0,a.jsx)(n.code,{children:"!regex"})," function to extract the post number from the ",(0,a.jsx)(n.code,{children:"title"})," string. For example:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:'- implementation: nodestream.interpreting:Interpreter\n  arguments:\n    interpretations:\n      - type: source_node\n        node_type: Post\n        key:\n          id: !jmespath post_id\n      - type: variables\n        variables:\n          post_number: !regex\n            string: !jmespath title\n            pattern: "Post ([0-9]+):"\n      - type: relationship\n        relationship_type: HAS_SEQUENCE_NUMBER\n        node_type: SequenceNumber\n        find_many: true\n        node_key:\n          name: !variable post_number\n'})}),"\n",(0,a.jsxs)(n.p,{children:["By default, the value will be the result of the first capture group in the regular expression.\nIf you want to use a different capture group, you can specify the ",(0,a.jsx)(n.code,{children:"group"})," argument, which can be an integer for the capture group index or a string for the capture group name."]}),"\n",(0,a.jsx)(n.p,{children:"For example, you could rewrite our previous example to use a named capture group like this:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:'- implementation: nodestream.interpreting:Interpreter\n  arguments:\n    interpretations:\n      - type: source_node\n        node_type: Post\n        key:\n          id: !jmespath post_id\n      - type: variables\n        variables:\n          post_number: !regex\n            string: !jmespath title\n            pattern: "Post (?<number>[0-9]+):"\n            group: "number"\n      - type: relationship\n        relationship_type: HAS_SEQUENCE_NUMBER\n        node_type: SequenceNumber\n        find_many: true\n        node_key:\n          name: !variable post_number\n'})})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>s});var a=t(6540);const i={},r=a.createContext(i);function o(e){const n=a.useContext(r);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),a.createElement(r.Provider,{value:n},e.children)}}}]);